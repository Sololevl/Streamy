<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebRTC Demo — Receiver</title>
    <link rel="stylesheet" href="style/index.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Real-Time WebRTC VLM Object-Detector</h1>
      </header>

      <div class="panel">
        <div class="controls row">
          <button id="newRoomBtn">Create Room</button>
          <div>Room: <code id="roomId">-</code></div>
          <button id="saveMetricsBtn">Save metrics.json</button>
        </div>

        <div class="content">
          <div class="video-wrap">
            <!-- The canvas for bounding boxes will be inserted here by JS -->
            <video id="video" autoplay playsinline></video>
          </div>
          <div class="side">
            <div id="metricsBox" class="metrics">
              <div class="metric-item-placeholder">
                Metrics will appear here once the feed starts...
              </div>
            </div>
            <div id="qr" class="qr-card">
              <span class="hint">Create a room to get a QR code</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const ws = new WebSocket('wss://' + location.host);
      let roomId = null;
      let pc = null;
      let wsOpen = false;
      let joinSent = false;
      let clockDeltaMs = 0;
      const videoEl = document.getElementById('video');
      const videoWrapEl = document.querySelector('.video-wrap');
      let overlayCanvas = null;
      let overlayCtx = null;
      const metrics = {
        e2e: [], net: [], srv: [], frames: 0, startTs: 0, uplinkKbps: [], downlinkKbps: []
      };
      let downStatsTimer = null;
      let lastBytesRecv = null;
      let lastRecvTs = null;
      const statsBox = document.getElementById('metricsBox');

      function percentile(arr, p) {
        if (!arr.length) return 0;
        const a = [...arr].sort((x,y)=>x-y);
        const idx = Math.min(a.length-1, Math.floor((p/100)*a.length));
        return a[idx];
      }
      function median(arr) { return percentile(arr, 50); }
      
      function updateStatsBox() {
        const seconds = Math.max(1, (Date.now() - metrics.startTs) / 1000);
        const fps = (metrics.frames / seconds).toFixed(1);
        const med = Math.round(median(metrics.e2e));
        const p95 = Math.round(percentile(metrics.e2e, 95));
        const netMed = Math.round(median(metrics.net));
        const srvMed = Math.round(median(metrics.srv));
        const up = Math.round(median(metrics.uplinkKbps));
        const down = Math.round(median(metrics.downlinkKbps));
        
        statsBox.innerHTML = `
          <div class="metric-item"><span class="metric-label">FPS</span><span class="metric-value">${fps}</span></div>
          <div class="metric-item"><span class="metric-label">E2E Latency (p50)</span><span class="metric-value">${med} ms</span></div>
          <div class="metric-item"><span class="metric-label">E2E Latency (p95)</span><span class="metric-value">${p95} ms</span></div>
          <div class="metric-item"><span class="metric-label">Network Latency</span><span class="metric-value">${netMed} ms</span></div>
          <div class="metric-item"><span class="metric-label">Server Latency</span><span class="metric-value">${srvMed} ms</span></div>
          <div class="metric-item"><span class="metric-label">Uplink</span><span class="metric-value">${isFinite(up) ? up.toFixed(1) : '-'} kbps</span></div>
          <div class="metric-item"><span class="metric-label">Downlink</span><span class="metric-value">${isFinite(down) ? down.toFixed(1) : '-'} kbps</span></div>
        `;
      }

      async function downloadMetricsJSON() {
        if (metrics.frames === 0) {
            const notification = document.createElement('div');
            notification.textContent = 'No metrics to save yet.';
            notification.className = 'notification error';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
            return;
        }
        const seconds = Math.max(1, (Date.now() - metrics.startTs) / 1000);
        const fps = metrics.frames / seconds;
        const body = {
          median_e2e_ms: median(metrics.e2e), p95_e2e_ms: percentile(metrics.e2e, 95),
          median_network_ms: median(metrics.net), median_server_ms: median(metrics.srv),
          fps: Number(fps.toFixed(2)), uplink_kbps: Math.round(median(metrics.uplinkKbps)) || null,
          downlink_kbps: Math.round(median(metrics.downlinkKbps)) || null
        };
        try {
          await fetch('/api/metrics', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
          const a = document.createElement('a');
          const blob = new Blob([JSON.stringify(body, null, 2)], { type: 'application/json' });
          a.href = URL.createObjectURL(blob);
          a.download = 'metrics.json';
          a.click();
        } catch (e) { 
            const notification = document.createElement('div');
            notification.textContent = 'Failed to save metrics.';
            notification.className = 'notification error';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }
      }

      setInterval(async () => {
        if (!metrics.startTs) return;
        try {
          const seconds = Math.max(1, (Date.now() - metrics.startTs) / 1000);
          const fps = metrics.frames / seconds;
          const body = {
            median_e2e_ms: median(metrics.e2e), p95_e2e_ms: percentile(metrics.e2e, 95),
            median_network_ms: median(metrics.net), median_server_ms: median(metrics.srv),
            fps: Number(fps.toFixed(2)), uplink_kbps: Math.round(median(metrics.uplinkKbps)) || null,
            downlink_kbps: Math.round(median(metrics.downlinkKbps)) || null
          };
          await fetch('/api/metrics', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        } catch {}
      }, 1000);
      const newRoomBtn = document.getElementById('newRoomBtn');
      newRoomBtn.disabled = true;

      function log(...args) { console.log('[receiver]', ...args); }

      function connectWS() {
        ws.addEventListener('open', () => {
          wsOpen = true; newRoomBtn.disabled = false; log('ws open');
          if (roomId && !joinSent) { ws.send(JSON.stringify({ type: 'join', roomId })); joinSent = true; }
        });
        ws.addEventListener('message', async (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'joined') return;
          if (!pc && msg.type === 'offer') createPeer();
          if (msg.type === 'offer') {
            await pc.setRemoteDescription(msg.offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type: 'answer', roomId, answer }));
          } else if (msg.type === 'candidate') {
            try { await pc.addIceCandidate(msg.candidate); } catch {}
          }
        });
      }

      function startClockSync(dc) {
        try { const t0 = Date.now(); dc.send(JSON.stringify({ type: 'sync_req', t0 })); } catch {}
      }

      const tracks = new Map(); let nextId = 1;
      function iou(a, b) {
        const interX = Math.max(0, Math.min(a.xmax, b.xmax) - Math.max(a.xmin, b.xmin));
        const interY = Math.max(0, Math.min(a.ymax, b.ymax) - Math.max(a.ymin, b.ymin));
        const inter = interX * interY;
        const union = (a.xmax - a.xmin) * (a.ymax - a.ymin) + (b.xmax - b.xmin) * (b.ymax - b.ymin) - inter;
        return union > 0 ? inter / union : 0;
      }

      // --- MODIFIED FUNCTION ---
      // This function now only deals with normalized (0-1) coordinates.
      function updateTracks(dets) {
        const candidates = dets.map(d => ({
          xmin: d.xmin, ymin: d.ymin, xmax: d.xmax, ymax: d.ymax,
          label: d.label, score: d.score
        }));

        for (const [id, t] of tracks) t.ttl -= 1;

        for (const cand of candidates) {
          let bestId = null, bestIoU = 0;
          for (const [id, t] of tracks) {
            const val = iou(t, cand); if (val > bestIoU) { bestIoU = val; bestId = id; }
          }
          if (bestId && bestIoU > 0.2) {
            const t = tracks.get(bestId);
            const alpha = 0.5; // Smoothing factor
            t.xmin = t.xmin * (1 - alpha) + cand.xmin * alpha;
            t.ymin = t.ymin * (1 - alpha) + cand.ymin * alpha;
            t.xmax = t.xmax * (1 - alpha) + cand.xmax * alpha;
            t.ymax = t.ymax * (1 - alpha) + cand.ymax * alpha;
            t.label = cand.label; t.score = cand.score; t.ttl = 5;
          } else {
            tracks.set(nextId++, { ...cand, ttl: 5 });
          }
        }
        for (const [id, t] of [...tracks]) if (t.ttl <= 0) tracks.delete(id);
        videoWrapEl.classList.toggle('detected', tracks.size > 0);
      }

      // --- MODIFIED FUNCTION ---
      // This function now handles converting normalized coordinates to pixels.
      function renderTracks() {
        if (!overlayCanvas || !overlayCtx || !videoEl.videoWidth) {
            requestAnimationFrame(renderTracks);
            return;
        }
        
        const videoRect = videoEl.getBoundingClientRect();
        if (overlayCanvas.width !== videoRect.width || overlayCanvas.height !== videoRect.height) {
          overlayCanvas.width = videoRect.width;
          overlayCanvas.height = videoRect.height;
        }
        
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        
        const pulse = (Math.sin(Date.now() / 200) + 1) / 2;
        const baseLineWidth = 2;
        const pulseLineWidth = baseLineWidth + pulse * 2;
        
        for (const [id, t] of tracks) {
          // Convert normalized coordinates to pixel coordinates HERE
          const x = t.xmin * overlayCanvas.width;
          const y = t.ymin * overlayCanvas.height;
          const w = (t.xmax - t.xmin) * overlayCanvas.width;
          const h = (t.ymax - t.ymin) * overlayCanvas.height;

          overlayCtx.strokeStyle = `rgba(0, 245, 255, ${0.7 + pulse * 0.3})`;
          overlayCtx.lineWidth = pulseLineWidth;
          overlayCtx.shadowBlur = 15;
          overlayCtx.shadowColor = `rgba(0, 245, 255, 0.7)`;
          overlayCtx.strokeRect(x, y, w, h);
          overlayCtx.shadowBlur = 0;
          
          const label = `${t.label} ${(t.score*100).toFixed(0)}%`;
          overlayCtx.font = '14px "JetBrains Mono", monospace';
          const textMetrics = overlayCtx.measureText(label);
          
          overlayCtx.fillStyle = 'rgba(0,0,0,0.7)';
          overlayCtx.fillRect(x, Math.max(0, y - 22), textMetrics.width + 12, 22);
          overlayCtx.fillStyle = '#fff';
          overlayCtx.fillText(label, x + 6, Math.max(14, y - 6));
        }
        requestAnimationFrame(renderTracks);
      }

      function createPeer() {
        pc = new RTCPeerConnection({ iceServers: [ { urls: ['stun:stun.l.google.com:19302'] } ] });
        pc.ontrack = (ev) => {
          videoEl.srcObject = ev.streams[0];
          if (!overlayCanvas) {
            overlayCanvas = document.createElement('canvas');
            overlayCanvas.className = 'overlay-canvas';
            videoWrapEl.appendChild(overlayCanvas);
            overlayCtx = overlayCanvas.getContext('2d');
          }
          requestAnimationFrame(renderTracks); 
          startDownlinkSampling();
        };
        pc.onicecandidate = (ev) => {
          if (ev.candidate) ws.send(JSON.stringify({ type: 'candidate', roomId, candidate: ev.candidate }));
        };
        pc.ondatachannel = (ev) => {
          if (ev.channel.label === 'meta') {
            const ch = ev.channel;
            startClockSync(ch);
            ch.onmessage = (e) => {
              try {
                const msg = JSON.parse(e.data);
                // The console.log to verify data arrival
                // console.log("Received data:", msg); 

                if (msg.type === 'uplink_kbps' && typeof msg.kbps === 'number') {
                  metrics.uplinkKbps.push(msg.kbps); if (metrics.uplinkKbps.length > 120) metrics.uplinkKbps.shift();
                  return;
                }
                if (msg.type === 'sync_res' && typeof msg.t_phone === 'number') {
                  clockDeltaMs = msg.t_phone - Date.now(); return;
                }
                if (!metrics.startTs) metrics.startTs = Date.now();
                metrics.frames += 1;
                const now = Date.now();

                // adjusted sender timestamps
                const cap = (msg.capture_ts || now) - clockDeltaMs; // capture time on phone
                const rcv = (msg.recv_ts || now) - clockDeltaMs;   // send time from phone (just before send)
                const inf = (msg.inference_ts || now) - clockDeltaMs; // inference completion time on phone

                // end-to-end latency
                const e2e = Math.max(0, now - cap);

                // server-side processing (phone processing) — compute relative to capture
                const srv = Math.max(0, inf - cap);

                // network/queuing time before send — prefer rcv - cap; fall back to e2e - srv
                let net = rcv - cap;
                if (!Number.isFinite(net) || net <= 0) {
                        net = Math.max(1, Math.round(e2e - srv)); // at least 1 ms
                }

                // push metrics (bounded arrays)
                metrics.e2e.push(e2e);
                metrics.net.push(net);
                metrics.srv.push(srv);
                if (metrics.e2e.length > 300) { metrics.e2e.shift(); metrics.net.shift(); metrics.srv.shift(); }

                updateStatsBox();
                updateTracks(msg.detections || []);
              } catch {}
            };
            ch.onclose = () => {
              Object.assign(metrics, { e2e: [], net: [], srv: [], frames: 0, startTs: 0, uplinkKbps: [], downlinkKbps: [] });
              tracks.clear(); videoWrapEl.classList.remove('detected');
              if (downStatsTimer) { clearInterval(downStatsTimer); downStatsTimer = null; }
            };
          }
        };
      }

      function startDownlinkSampling() {
        if (downStatsTimer) clearInterval(downStatsTimer);
        downStatsTimer = setInterval(async () => {
          if (!pc) return;
          try {
            const stats = await pc.getStats();
            stats.forEach(report => {
              if (report.type === 'inbound-rtp' && report.kind === 'video') {
                const bytes = report.bytesReceived, ts = report.timestamp;
                if (lastBytesRecv != null && lastRecvTs != null) {
                  const deltaMs = ts - lastRecvTs;
                  if (deltaMs > 0) {
                    const kbps = (bytes - lastBytesRecv) * 8 / deltaMs;
                    metrics.downlinkKbps.push(kbps);
                    if (metrics.downlinkKbps.length > 120) metrics.downlinkKbps.shift();
                  }
                }
                lastBytesRecv = bytes; lastRecvTs = ts;
              }
            });
          } catch {}
        }, 1000);
      }

      async function createRoom() {
        newRoomBtn.disabled = true;
        try {
          const res = await fetch('/api/new-room');
          const data = await res.json();
          roomId = data.roomId;
          document.getElementById('roomId').textContent = roomId;
          const url = data.phoneUrl || (location.origin + data.phonePath);
          const qrDiv = document.getElementById('qr');
          qrDiv.innerHTML = ''; // Clear previous QR/hint
          const img = new Image();
          img.alt = 'QR Code to join room';
          img.src = '/api/qr?data=' + encodeURIComponent(url);
          qrDiv.appendChild(img);
          qrDiv.classList.add('visible'); // Trigger fade-in animation
          if (ws.readyState === 1) {
            ws.send(JSON.stringify({ type: 'join', roomId })); joinSent = true;
          } else {
            ws.addEventListener('open', () => {
              if (!joinSent) { ws.send(JSON.stringify({ type: 'join', roomId })); joinSent = true; }
            }, { once: true });
          }
          createPeer();
        } catch (e) { 
            const notification = document.createElement('div');
            notification.textContent = 'Failed to create room. Check server.';
            notification.className = 'notification error';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }
        newRoomBtn.disabled = false;
      }

      document.getElementById('newRoomBtn').addEventListener('click', createRoom);
      document.getElementById('saveMetricsBtn').addEventListener('click', downloadMetricsJSON);
      connectWS();
    </script>
  </body>
</html>

